{"version":3,"file":"talk-JitsiEncryptionWorker.worker.worker.js?v=c072f73c847b88fc108d","mappings":"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","sources":["webpack:///talk/src/utils/e2ee/crypto-utils.js","webpack:///talk/src/utils/e2ee/JitsiEncryptionWorkerContext.js","webpack:///talk/src/utils/e2ee/JitsiEncryptionWorker.worker.js"],"sourcesContent":["/**\n * SPDX-FileCopyrightText: 2020 Jitsi team at 8x8 and the community.\n * SPDX-License-Identifier: Apache-2.0\n *\n * Based on code from https://github.com/jitsi/jitsi-meet\n */\n\n/**\n * Derives a set of keys from the master key.\n * @param {CryptoKey} material - master key to derive from\n *\n * See https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.1\n */\nexport async function deriveKeys(material) {\n\tconst info = new ArrayBuffer()\n\tconst textEncoder = new TextEncoder()\n\n\t// https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveKey#HKDF\n\t// https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams\n\tconst encryptionKey = await crypto.subtle.deriveKey({\n\t\tname: 'HKDF',\n\t\tsalt: textEncoder.encode('TalkFrameEncryptionKey'),\n\t\thash: 'SHA-256',\n\t\tinfo,\n\t}, material, {\n\t\tname: 'AES-GCM',\n\t\tlength: 128,\n\t}, false, ['encrypt', 'decrypt'])\n\n\treturn {\n\t\tmaterial,\n\t\tencryptionKey,\n\t}\n}\n\n/**\n * Ratchets a key. See\n * https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.5.1\n * @param {CryptoKey} material - base key material\n * @returns {Promise<ArrayBuffer>} - ratcheted key material\n */\nexport async function ratchet(material) {\n\tconst textEncoder = new TextEncoder()\n\n\t// https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveBits\n\treturn crypto.subtle.deriveBits({\n\t\tname: 'HKDF',\n\t\tsalt: textEncoder.encode('TalkFrameRatchetKey'),\n\t\thash: 'SHA-256',\n\t\tinfo: new ArrayBuffer(),\n\t}, material, 256)\n}\n\n/**\n * Converts a raw key into a WebCrypto key object with default options\n * suitable for our usage.\n * @param {ArrayBuffer} keyBytes - raw key\n * @param {Array} keyUsages - key usages, see importKey documentation\n * @returns {Promise<CryptoKey>} - the WebCrypto key.\n */\nexport async function importKey(keyBytes) {\n\t// https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey\n\treturn crypto.subtle.importKey('raw', keyBytes, 'HKDF', false, ['deriveBits', 'deriveKey'])\n}\n","/**\n * SPDX-FileCopyrightText: 2020 Jitsi team at 8x8 and the community.\n * SPDX-License-Identifier: Apache-2.0\n *\n * Based on code from https://github.com/jitsi/jitsi-meet\n */\n\nimport { deriveKeys, importKey, ratchet } from './crypto-utils.js'\n\n// We use a ringbuffer of keys so we can change them and still decode packets that were\n// encrypted with an old key. We use a size of 16 which corresponds to the four bits\n// in the frame trailer.\nconst KEYRING_SIZE = 16\n\n// We copy the first bytes of the VP8 payload unencrypted.\n// For keyframes this is 10 bytes, for non-keyframes (delta) 3. See\n//   https://tools.ietf.org/html/rfc6386#section-9.1\n// This allows the bridge to continue detecting keyframes (only one byte needed in the JVB)\n// and is also a bit easier for the VP8 decoder (i.e. it generates funny garbage pictures\n// instead of being unable to decode).\n// This is a bit for show and we might want to reduce to 1 unconditionally in the final version.\n//\n// For audio (where frame.type is not set) we do not encrypt the opus TOC byte:\n//   https://tools.ietf.org/html/rfc6716#section-3.1\nconst UNENCRYPTED_BYTES = {\n\tkey: 10,\n\tdelta: 3,\n\tundefined: 1, // frame.type is not set on audio\n}\nconst ENCRYPTION_ALGORITHM = 'AES-GCM'\n\n/* We use a 96 bit IV for AES GCM. This is signalled in plain together with the\n packet. See https://developer.mozilla.org/en-US/docs/Web/API/AesGcmParams */\nconst IV_LENGTH = 12\n\nconst RATCHET_WINDOW_SIZE = 8\n\n/**\n * Per-participant context holding the cryptographic keys and\n * encode/decode functions\n */\nexport class Context {\n\t/**\n\t * @param {Object} options\n\t */\n\tconstructor({ sharedKey = false } = {}) {\n\t\t// An array (ring) of keys that we use for sending and receiving.\n\t\tthis._cryptoKeyRing = new Array(KEYRING_SIZE)\n\n\t\t// A pointer to the currently used key.\n\t\tthis._currentKeyIndex = -1\n\n\t\tthis._sendCounts = new Map()\n\n\t\tthis._sharedKey = sharedKey\n\t}\n\n\t/**\n\t * Derives the different subkeys and starts using them for encryption or\n\t * decryption.\n\t * @param {Uint8Array|false} key bytes. Pass false to disable.\n\t * @param {Number} keyIndex\n\t */\n\tasync setKey(key, keyIndex = -1) {\n\t\tlet newKey = false\n\n\t\tif (key) {\n\t\t\tif (this._sharedKey) {\n\t\t\t\tnewKey = key\n\t\t\t} else {\n\t\t\t\tconst material = await importKey(key)\n\n\t\t\t\tnewKey = await deriveKeys(material)\n\t\t\t}\n\t\t}\n\n\t\tthis._setKeys(newKey, keyIndex)\n\t}\n\n\t/**\n\t * Sets a set of keys and resets the sendCount.\n\t * decryption.\n\t * @param {Object} keys set of keys.\n\t * @param {Number} keyIndex optional\n\t * @private\n\t */\n\t_setKeys(keys, keyIndex = -1) {\n\t\tif (keyIndex >= 0) {\n\t\t\tthis._currentKeyIndex = keyIndex % this._cryptoKeyRing.length\n\t\t}\n\n\t\tthis._cryptoKeyRing[this._currentKeyIndex] = keys\n\n\t\tthis._sendCount = BigInt(0)\n\t}\n\n\t/**\n\t * Function that will be injected in a stream and will encrypt the given encoded frames.\n\t *\n\t * @param {RTCEncodedVideoFrame|RTCEncodedAudioFrame} encodedFrame - Encoded video frame.\n\t * @param {TransformStreamDefaultController} controller - TransportStreamController.\n\t *\n\t * The VP8 payload descriptor described in\n\t * https://tools.ietf.org/html/rfc7741#section-4.2\n\t * is part of the RTP packet and not part of the frame and is not controllable by us.\n\t * This is fine as the SFU keeps having access to it for routing.\n\t *\n\t * The encrypted frame is formed as follows:\n\t * 1) Leave the first (10, 3, 1) bytes unencrypted, depending on the frame type and kind.\n\t * 2) Form the GCM IV for the frame as described above.\n\t * 3) Encrypt the rest of the frame using AES-GCM.\n\t * 4) Allocate space for the encrypted frame.\n\t * 5) Copy the unencrypted bytes to the start of the encrypted frame.\n\t * 6) Append the ciphertext to the encrypted frame.\n\t * 7) Append the IV.\n\t * 8) Append a single byte for the key identifier.\n\t * 9) Enqueue the encrypted frame for sending.\n\t */\n\tencodeFunction(encodedFrame, controller) {\n\t\tconst keyIndex = this._currentKeyIndex\n\n\t\tif (this._cryptoKeyRing[keyIndex]) {\n\t\t\tconst iv = this._makeIV(encodedFrame.getMetadata().synchronizationSource, encodedFrame.timestamp)\n\n\t\t\t// Thіs is not encrypted and contains the VP8 payload descriptor or the Opus TOC byte.\n\t\t\tconst frameHeader = new Uint8Array(encodedFrame.data, 0, UNENCRYPTED_BYTES[encodedFrame.type])\n\n\t\t\t// Frame trailer contains the R|IV_LENGTH and key index\n\t\t\tconst frameTrailer = new Uint8Array(2)\n\n\t\t\tframeTrailer[0] = IV_LENGTH\n\t\t\tframeTrailer[1] = keyIndex\n\n\t\t\t// Construct frame trailer. Similar to the frame header described in\n\t\t\t// https://tools.ietf.org/html/draft-omara-sframe-00#section-4.2\n\t\t\t// but we put it at the end.\n\t\t\t//\n\t\t\t// ---------+-------------------------+-+---------+----\n\t\t\t// payload  |IV...(length = IV_LENGTH)|R|IV_LENGTH|KID |\n\t\t\t// ---------+-------------------------+-+---------+----\n\n\t\t\treturn crypto.subtle.encrypt({\n\t\t\t\tname: ENCRYPTION_ALGORITHM,\n\t\t\t\tiv,\n\t\t\t\tadditionalData: new Uint8Array(encodedFrame.data, 0, frameHeader.byteLength),\n\t\t\t}, this._cryptoKeyRing[keyIndex].encryptionKey, new Uint8Array(\n\t\t\t\tencodedFrame.data,\n\t\t\t\tUNENCRYPTED_BYTES[encodedFrame.type],\n\t\t\t))\n\t\t\t\t.then((cipherText) => {\n\t\t\t\t\tconst newData = new ArrayBuffer(frameHeader.byteLength + cipherText.byteLength\n\t\t\t\t\t\t+ iv.byteLength + frameTrailer.byteLength)\n\t\t\t\t\tconst newUint8 = new Uint8Array(newData)\n\n\t\t\t\t\tnewUint8.set(frameHeader) // copy first bytes.\n\t\t\t\t\tnewUint8.set(new Uint8Array(cipherText), frameHeader.byteLength) // add ciphertext.\n\t\t\t\t\tnewUint8.set(new Uint8Array(iv), frameHeader.byteLength + cipherText.byteLength) // append IV.\n\t\t\t\t\tnewUint8.set(\n\t\t\t\t\t\tframeTrailer,\n\t\t\t\t\t\tframeHeader.byteLength + cipherText.byteLength + iv.byteLength,\n\t\t\t\t\t) // append frame trailer.\n\n\t\t\t\t\tencodedFrame.data = newData\n\n\t\t\t\t\treturn controller.enqueue(encodedFrame)\n\t\t\t\t}, (e) => {\n\t\t\t\t\t// TODO: surface this to the app.\n\t\t\t\t\tconsole.error(e)\n\n\t\t\t\t\t// We are not enqueuing the frame here on purpose.\n\t\t\t\t})\n\t\t}\n\n\t\t/* NOTE WELL:\n\t\t * This will send unencrypted data (only protected by DTLS transport encryption) when no key is configured.\n\t\t * This is ok for demo purposes but should not be done once this becomes more relied upon.\n\t\t */\n\t\tcontroller.enqueue(encodedFrame)\n\t}\n\n\t/**\n\t * Function that will be injected in a stream and will decrypt the given encoded frames.\n\t *\n\t * @param {RTCEncodedVideoFrame|RTCEncodedAudioFrame} encodedFrame - Encoded video frame.\n\t * @param {TransformStreamDefaultController} controller - TransportStreamController.\n\t */\n\tasync decodeFunction(encodedFrame, controller) {\n\t\tconst data = new Uint8Array(encodedFrame.data)\n\t\tconst keyIndex = data[encodedFrame.data.byteLength - 1]\n\n\t\tif (this._cryptoKeyRing[keyIndex]) {\n\t\t\tconst decodedFrame = await this._decryptFrame(\n\t\t\t\tencodedFrame,\n\t\t\t\tkeyIndex,\n\t\t\t)\n\n\t\t\tif (decodedFrame) {\n\t\t\t\tcontroller.enqueue(decodedFrame)\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Function that will decrypt the given encoded frame. If the decryption fails, it will\n\t * ratchet the key for up to RATCHET_WINDOW_SIZE times.\n\t *\n\t * @param {RTCEncodedVideoFrame|RTCEncodedAudioFrame} encodedFrame - Encoded video frame.\n\t * @param {number} keyIndex - the index of the decryption data in _cryptoKeyRing array.\n\t * @param {number} ratchetCount - the number of retries after ratcheting the key.\n\t * @returns {Promise<RTCEncodedVideoFrame|RTCEncodedAudioFrame>} - The decrypted frame.\n\t * @private\n\t */\n\tasync _decryptFrame(\n\t\tencodedFrame,\n\t\tkeyIndex,\n\t\t\tinitialKey = undefined,\n\t\t\tratchetCount = 0,\n\t) {\n\t\tconst { encryptionKey } = this._cryptoKeyRing[keyIndex]\n\t\tlet { material } = this._cryptoKeyRing[keyIndex]\n\n\t\t// Construct frame trailer. Similar to the frame header described in\n\t\t// https://tools.ietf.org/html/draft-omara-sframe-00#section-4.2\n\t\t// but we put it at the end.\n\t\t//\n\t\t// ---------+-------------------------+-+---------+----\n\t\t// payload  |IV...(length = IV_LENGTH)|R|IV_LENGTH|KID |\n\t\t// ---------+-------------------------+-+---------+----\n\n\t\ttry {\n\t\t\tconst frameHeader = new Uint8Array(encodedFrame.data, 0, UNENCRYPTED_BYTES[encodedFrame.type])\n\t\t\tconst frameTrailer = new Uint8Array(encodedFrame.data, encodedFrame.data.byteLength - 2, 2)\n\n\t\t\tconst ivLength = frameTrailer[0]\n\t\t\tconst iv = new Uint8Array(\n\t\t\t\tencodedFrame.data,\n\t\t\t\tencodedFrame.data.byteLength - ivLength - frameTrailer.byteLength,\n\t\t\t\tivLength,\n\t\t\t)\n\n\t\t\tconst cipherTextStart = frameHeader.byteLength\n\t\t\tconst cipherTextLength = encodedFrame.data.byteLength\n\t\t\t\t- (frameHeader.byteLength + ivLength + frameTrailer.byteLength)\n\n\t\t\tconst plainText = await crypto.subtle.decrypt(\n\t\t\t\t{\n\t\t\t\t\tname: 'AES-GCM',\n\t\t\t\t\tiv,\n\t\t\t\t\tadditionalData: new Uint8Array(encodedFrame.data, 0, frameHeader.byteLength),\n\t\t\t\t},\n\t\t\t\tencryptionKey,\n\t\t\t\tnew Uint8Array(encodedFrame.data, cipherTextStart, cipherTextLength),\n\t\t\t)\n\n\t\t\tconst newData = new ArrayBuffer(frameHeader.byteLength + plainText.byteLength)\n\t\t\tconst newUint8 = new Uint8Array(newData)\n\n\t\t\tnewUint8.set(new Uint8Array(encodedFrame.data, 0, frameHeader.byteLength))\n\t\t\tnewUint8.set(new Uint8Array(plainText), frameHeader.byteLength)\n\n\t\t\tencodedFrame.data = newData\n\n\t\t\treturn encodedFrame\n\t\t} catch (error) {\n\t\t\tif (this._sharedKey) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (ratchetCount < RATCHET_WINDOW_SIZE) {\n\t\t\t\tconst currentKey = this._cryptoKeyRing[this._currentKeyIndex]\n\n\t\t\t\tmaterial = await importKey(await ratchet(material))\n\n\t\t\t\tconst newKey = await deriveKeys(material)\n\n\t\t\t\tthis._setKeys(newKey)\n\n\t\t\t\treturn await this._decryptFrame(\n\t\t\t\t\tencodedFrame,\n\t\t\t\t\tkeyIndex,\n\t\t\t\t\tinitialKey || currentKey,\n\t\t\t\t\tratchetCount + 1,\n\t\t\t\t)\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Since the key it is first send and only afterwards actually used for encrypting, there were\n\t\t\t * situations when the decrypting failed due to the fact that the received frame was not encrypted\n\t\t\t * yet and ratcheting, of course, did not solve the problem. So if we fail RATCHET_WINDOW_SIZE times,\n\t\t\t * we come back to the initial key.\n\t\t\t */\n\t\t\tthis._setKeys(initialKey)\n\n\t\t\t// TODO: notify the application about error status.\n\t\t}\n\t}\n\n\t/**\n\t * Construct the IV used for AES-GCM and sent (in plain) with the packet similar to\n\t * https://tools.ietf.org/html/rfc7714#section-8.1\n\t * It concatenates\n\t * - the 32 bit synchronization source (SSRC) given on the encoded frame,\n\t * - the 32 bit rtp timestamp given on the encoded frame,\n\t * - a send counter that is specific to the SSRC. Starts at a random number.\n\t * The send counter is essentially the pictureId but we currently have to implement this ourselves.\n\t * There is no XOR with a salt. Note that this IV leaks the SSRC to the receiver but since this is\n\t * randomly generated and SFUs may not rewrite this is considered acceptable.\n\t * The SSRC is used to allow demultiplexing multiple streams with the same key, as described in\n\t *   https://tools.ietf.org/html/rfc3711#section-4.1.1\n\t * The RTP timestamp is 32 bits and advances by the codec clock rate (90khz for video, 48khz for\n\t * opus audio) every second. For video it rolls over roughly every 13 hours.\n\t * The send counter will advance at the frame rate (30fps for video, 50fps for 20ms opus audio)\n\t * every second. It will take a long time to roll over.\n\t *\n\t * See also https://developer.mozilla.org/en-US/docs/Web/API/AesGcmParams\n\t */\n\t_makeIV(synchronizationSource, timestamp) {\n\t\tconst iv = new ArrayBuffer(IV_LENGTH)\n\t\tconst ivView = new DataView(iv)\n\n\t\t// having to keep our own send count (similar to a picture id) is not ideal.\n\t\tif (!this._sendCounts.has(synchronizationSource)) {\n\t\t\t// Initialize with a random offset, similar to the RTP sequence number.\n\t\t\tthis._sendCounts.set(synchronizationSource, Math.floor(Math.random() * 0xFFFF))\n\t\t}\n\n\t\tconst sendCount = this._sendCounts.get(synchronizationSource)\n\n\t\tivView.setUint32(0, synchronizationSource)\n\t\tivView.setUint32(4, timestamp)\n\t\tivView.setUint32(8, sendCount % 0xFFFF)\n\n\t\tthis._sendCounts.set(synchronizationSource, sendCount + 1)\n\n\t\treturn iv\n\t}\n}\n","/**\n * SPDX-FileCopyrightText: 2020 Jitsi team at 8x8 and the community.\n * SPDX-License-Identifier: Apache-2.0\n *\n * Based on code from https://github.com/jitsi/jitsi-meet\n */\n\n// Worker for E2EE/Insertable streams.\n\nimport { Context } from './JitsiEncryptionWorkerContext.js'\n\nconst contexts = new Map() // Map participant id => context\n\nlet sharedContext\n\n/**\n * Retrieves the participant {@code Context}, creating it if necessary.\n *\n * @param {string} participantId - The participant whose context we need.\n * @returns {Object} The context.\n */\nfunction getParticipantContext(participantId) {\n\tif (sharedContext) {\n\t\treturn sharedContext\n\t}\n\n\tif (!contexts.has(participantId)) {\n\t\tcontexts.set(participantId, new Context())\n\t}\n\n\treturn contexts.get(participantId)\n}\n\n/**\n * Sets an encode / decode transform.\n *\n * @param {Object} context - The participant context where the transform will be applied.\n * @param {string} operation - Encode / decode.\n * @param {Object} readableStream - Readable stream part.\n * @param {Object} writableStream - Writable stream part.\n */\nfunction handleTransform(context, operation, readableStream, writableStream) {\n\tif (operation === 'encode' || operation === 'decode') {\n\t\tconst transformFn = operation === 'encode' ? context.encodeFunction : context.decodeFunction\n\t\tconst transformStream = new TransformStream({\n\t\t\ttransform: transformFn.bind(context),\n\t\t})\n\n\t\treadableStream\n\t\t\t.pipeThrough(transformStream)\n\t\t\t.pipeTo(writableStream)\n\t} else {\n\t\tconsole.error(`Invalid operation: ${operation}`)\n\t}\n}\n\nonmessage = async (event) => {\n\tconst { operation } = event.data\n\n\tif (operation === 'initialize') {\n\t\tconst { sharedKey } = event.data\n\n\t\tif (sharedKey) {\n\t\t\tsharedContext = new Context({ sharedKey })\n\t\t}\n\t} else if (operation === 'encode' || operation === 'decode') {\n\t\tconst { readableStream, writableStream, participantId } = event.data\n\t\tconst context = getParticipantContext(participantId)\n\n\t\thandleTransform(context, operation, readableStream, writableStream)\n\t} else if (operation === 'setKey') {\n\t\tconst { participantId, key, keyIndex } = event.data\n\t\tconst context = getParticipantContext(participantId)\n\n\t\tif (key) {\n\t\t\tcontext.setKey(key, keyIndex)\n\t\t} else {\n\t\t\tcontext.setKey(false, keyIndex)\n\t\t}\n\t} else if (operation === 'cleanup') {\n\t\tconst { participantId } = event.data\n\n\t\tcontexts.delete(participantId)\n\t} else if (operation === 'cleanupAll') {\n\t\tcontexts.clear()\n\t} else {\n\t\tconsole.error('e2ee worker', operation)\n\t}\n}\n\n// Operations using RTCRtpScriptTransform.\nif (self.RTCTransformEvent) {\n\tself.onrtctransform = (event) => {\n\t\tconst transformer = event.transformer\n\t\tconst { operation, participantId } = transformer.options\n\t\tconst context = getParticipantContext(participantId)\n\n\t\thandleTransform(context, operation, transformer.readable, transformer.writable)\n\t}\n}\n"],"names":["deriveKeys","material","info","textEncoder","encryptionKey","ratchet","importKey","keyBytes","KEYRING_SIZE","UNENCRYPTED_BYTES","ENCRYPTION_ALGORITHM","IV_LENGTH","RATCHET_WINDOW_SIZE","Context","sharedKey","key","keyIndex","newKey","keys","encodedFrame","controller","iv","frameHeader","frameTrailer","cipherText","newData","newUint8","e","decodedFrame","initialKey","ratchetCount","ivLength","cipherTextStart","cipherTextLength","plainText","currentKey","synchronizationSource","timestamp","ivView","sendCount","contexts","sharedContext","getParticipantContext","participantId","handleTransform","context","operation","readableStream","writableStream","transformFn","transformStream","event","transformer"],"sourceRoot":""}